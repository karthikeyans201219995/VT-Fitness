"""
API routes for invoice generation and management
"""
from fastapi import APIRouter, HTTPException, Depends, status, Response
from fastapi.responses import StreamingResponse
from typing import List, Optional
from datetime import datetime, date
import io
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from models_phase1 import (
    Invoice,
    InvoiceCreate,
    InvoiceUpdate,
    InvoiceStatus
)
from supabase_client import get_supabase
from services.invoice_service import invoice_service

router = APIRouter(prefix="/api/invoices", tags=["invoices"])


@router.post("/", response_model=dict, status_code=status.HTTP_201_CREATED)
async def create_invoice(invoice: InvoiceCreate):
    """Create a new invoice"""
    try:
        supabase = get_supabase()
        
        # Calculate tax amounts
        subtotal = invoice.subtotal
        discount = invoice.discount_amount
        taxable_amount = subtotal - discount
        
        tax_calculation = invoice_service.calculate_gst(
            taxable_amount,
            invoice.tax_rate,
            same_state=True  # TODO: Make this configurable based on member state
        )
        
        # Prepare invoice data
        invoice_data = {
            "member_id": invoice.member_id,
            "payment_id": invoice.payment_id,
            "installment_payment_id": invoice.installment_payment_id,
            "invoice_date": invoice.invoice_date.isoformat(),
            "due_date": invoice.due_date.isoformat() if invoice.due_date else None,
            "subtotal": subtotal,
            "discount_amount": discount,
            "tax_rate": invoice.tax_rate,
            "tax_amount": tax_calculation["tax_amount"],
            "cgst": tax_calculation["cgst"],
            "sgst": tax_calculation["sgst"],
            "igst": tax_calculation["igst"],
            "total_amount": tax_calculation["total"],
            "gstin": invoice.gstin or invoice_service.gym_gstin,
            "items": [item.model_dump() for item in invoice.items],
            "notes": invoice.notes,
            "terms": invoice.terms or "Payment is due within 7 days of invoice date.",
            "status": "draft"
        }
        
        # Insert invoice (invoice_number will be auto-generated by trigger)
        result = supabase.table("invoices").insert(invoice_data).execute()
        
        if not result.data:
            raise HTTPException(status_code=400, detail="Failed to create invoice")
        
        return {
            "message": "Invoice created successfully",
            "data": result.data[0]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating invoice: {str(e)}")


@router.get("/", response_model=dict)
async def get_invoices(
    member_id: Optional[str] = None,
    status: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    skip: int = 0,
    limit: int = 50
):
    """Get all invoices with optional filters"""
    try:
        supabase = get_supabase()
        
        query = supabase.table("invoices").select("*")
        
        if member_id:
            query = query.eq("member_id", member_id)
        
        if status:
            query = query.eq("status", status)
        
        if start_date:
            query = query.gte("invoice_date", start_date)
        
        if end_date:
            query = query.lte("invoice_date", end_date)
        
        result = query.order("invoice_date", desc=True).range(skip, skip + limit - 1).execute()
        
        return {
            "data": result.data,
            "count": len(result.data)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching invoices: {str(e)}")


@router.get("/{invoice_id}", response_model=dict)
async def get_invoice(invoice_id: str):
    """Get a specific invoice by ID"""
    try:
        supabase = get_supabase()
        
        result = supabase.table("invoices").select("*, members!inner(full_name, email, phone, address)").eq("id", invoice_id).execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        return {"data": result.data[0]}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching invoice: {str(e)}")


@router.get("/number/{invoice_number}", response_model=dict)
async def get_invoice_by_number(invoice_number: str):
    """Get invoice by invoice number"""
    try:
        supabase = get_supabase()
        
        result = supabase.table("invoices").select("*, members!inner(full_name, email, phone, address)").eq("invoice_number", invoice_number).execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        return {"data": result.data[0]}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching invoice: {str(e)}")


@router.patch("/{invoice_id}", response_model=dict)
async def update_invoice(invoice_id: str, update: InvoiceUpdate):
    """Update an invoice"""
    try:
        supabase = get_supabase()
        
        update_data = update.model_dump(exclude_unset=True)
        
        # Convert enums and dates to strings
        if 'status' in update_data:
            update_data['status'] = update_data['status'].value
        if 'due_date' in update_data and update_data['due_date']:
            update_data['due_date'] = update_data['due_date'].isoformat()
        
        update_data['updated_at'] = datetime.utcnow().isoformat()
        
        result = supabase.table("invoices").update(update_data).eq("id", invoice_id).execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        return {
            "message": "Invoice updated successfully",
            "data": result.data[0]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating invoice: {str(e)}")


@router.delete("/{invoice_id}", response_model=dict)
async def cancel_invoice(invoice_id: str):
    """Cancel an invoice"""
    try:
        supabase = get_supabase()
        
        result = supabase.table("invoices").update({
            "status": "cancelled",
            "updated_at": datetime.utcnow().isoformat()
        }).eq("id", invoice_id).execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        return {"message": "Invoice cancelled successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error cancelling invoice: {str(e)}")


@router.post("/{invoice_id}/send", response_model=dict)
async def send_invoice(invoice_id: str):
    """Mark invoice as sent and optionally email to member"""
    try:
        supabase = get_supabase()
        
        # Get invoice with member details
        result = supabase.table("invoices").select("*, members!inner(full_name, email, phone, address)").eq("id", invoice_id).execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        invoice_data = result.data[0]
        
        # Update invoice status to sent
        supabase.table("invoices").update({
            "status": "sent",
            "updated_at": datetime.utcnow().isoformat()
        }).eq("id", invoice_id).execute()
        
        # TODO: Send email with invoice PDF attachment
        # This would use the notification service
        
        return {
            "message": "Invoice marked as sent",
            "invoice_number": invoice_data["invoice_number"]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error sending invoice: {str(e)}")


@router.get("/{invoice_id}/download")
async def download_invoice(invoice_id: str):
    """Download invoice as PDF"""
    try:
        supabase = get_supabase()
        
        # Get invoice with member details
        result = supabase.table("invoices").select("*, members!inner(full_name, email, phone, address)").eq("id", invoice_id).execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Invoice not found")
        
        invoice_data = result.data[0]
        member_data = invoice_data["members"]
        
        # Generate PDF
        pdf_bytes = invoice_service.generate_invoice_pdf(invoice_data, member_data)
        
        # Return PDF as download
        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={
                "Content-Disposition": f'attachment; filename="invoice_{invoice_data["invoice_number"]}.pdf"'
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating invoice PDF: {str(e)}")


@router.post("/generate-from-payment/{payment_id}", response_model=dict)
async def generate_invoice_from_payment(payment_id: str):
    """Auto-generate invoice from a payment"""
    try:
        supabase = get_supabase()
        
        # Get payment details
        payment_result = supabase.table("payments").select("*, members!inner(full_name, email, phone, address), plans(name, price)").eq("id", payment_id).execute()
        
        if not payment_result.data:
            raise HTTPException(status_code=404, detail="Payment not found")
        
        payment = payment_result.data[0]
        member = payment["members"]
        plan = payment.get("plans")
        
        # Check if invoice already exists
        existing = supabase.table("invoices").select("id").eq("payment_id", payment_id).execute()
        if existing.data:
            raise HTTPException(status_code=400, detail="Invoice already exists for this payment")
        
        # Create invoice items
        items = [{
            "name": plan["name"] if plan else "Membership Payment",
            "description": f"Payment for {plan['name']}" if plan else "Gym membership payment",
            "quantity": 1,
            "rate": payment["amount"],
            "amount": payment["amount"]
        }]
        
        # Create invoice
        invoice_data = {
            "member_id": payment["member_id"],
            "payment_id": payment_id,
            "invoice_date": date.today().isoformat(),
            "due_date": date.today().isoformat(),
            "subtotal": payment["amount"],
            "discount_amount": 0,
            "tax_rate": 18.0,
            "items": items,
            "notes": f"Payment received via {payment['payment_method'].upper()}",
            "status": "paid"
        }
        
        # Calculate GST
        tax_calc = invoice_service.calculate_gst(payment["amount"], 18.0, same_state=True)
        invoice_data.update({
            "tax_amount": tax_calc["tax_amount"],
            "cgst": tax_calc["cgst"],
            "sgst": tax_calc["sgst"],
            "igst": tax_calc["igst"],
            "total_amount": tax_calc["total"]
        })
        
        result = supabase.table("invoices").insert(invoice_data).execute()
        
        return {
            "message": "Invoice generated successfully",
            "data": result.data[0]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating invoice: {str(e)}")


@router.get("/analytics/summary", response_model=dict)
async def get_invoice_analytics():
    """Get invoice analytics"""
    try:
        supabase = get_supabase()
        
        # Get all invoices
        all_invoices = supabase.table("invoices").select("total_amount, status, invoice_date").execute()
        
        total_invoiced = sum(inv["total_amount"] for inv in all_invoices.data)
        total_paid = sum(inv["total_amount"] for inv in all_invoices.data if inv["status"] == "paid")
        total_pending = sum(inv["total_amount"] for inv in all_invoices.data if inv["status"] in ["draft", "sent"])
        
        # Count by status
        draft_count = len([inv for inv in all_invoices.data if inv["status"] == "draft"])
        sent_count = len([inv for inv in all_invoices.data if inv["status"] == "sent"])
        paid_count = len([inv for inv in all_invoices.data if inv["status"] == "paid"])
        cancelled_count = len([inv for inv in all_invoices.data if inv["status"] == "cancelled"])
        
        return {
            "total_invoiced": total_invoiced,
            "total_paid": total_paid,
            "total_pending": total_pending,
            "total_count": len(all_invoices.data),
            "draft_count": draft_count,
            "sent_count": sent_count,
            "paid_count": paid_count,
            "cancelled_count": cancelled_count,
            "collection_rate": (total_paid / total_invoiced * 100) if total_invoiced > 0 else 0
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching analytics: {str(e)}")
